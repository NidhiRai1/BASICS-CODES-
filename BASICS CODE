include<bits/stdc++.h>   // for incliding of all the libraries
string s1 , s2 ; cin >> s1 >> s2 ;  cout<<s1 << " " << s2 ;  //" " print till their is no any gap in the string 
string str ; getline(cin , str) ; cout <<str ;  //it will print the entire line after the gaps also till the line break won't be their
char ch = 'n' ; cout<, ch ;

//array - similar type of datatype got stored and they are at contigeous memory location
int arr[n] = {0};
//function - it use to increase the readability
void function not retun it cout
pass by value - make the copy of original function and make the modificarion their but not change the original value in main function so answer remain the same as original
pass by reference (&)- pass the address of orginal so change happens on the original
*array alway  goes by reference else in vector , losr etc you have to apply & sign fro reference

//time complexity - rate at which the time taken increases with respect to the input taken , TC IN WORST CASE 
//SPACE COMPLEXITY - MEMORY SPACE = AUXALLARY SPACE (SPACE THAT YOU TAKE TO SOLE THE PROBLEM)  + INPUT SPACE (SPACE TO STORE THE INPUT)

//STL - 

//PAIR - 
piar<int , int> p1 = {1,2] ;  pair<int , int> p2 = {4 , 5} ;
cout<<p1.first <<p1.second;
p1.swap(p2) ;

//vector - it a contener for dinamic array which has an ability to resize itself .
vector<int > v ;
v.push_back(1) ;
vector<pair<int , int> v2;  v2.push_back({3 , 4}) ;
vector<int> v3(5 , 100) ;
vector<int> v4(v) ;
v.pop_back() ;
v.empty() ; // is your vector empty
v.clear() // clear the vector
for(auto it : v){cout<<it>>" " ; }
for(int i = 0 ; i < v.size() , i++){ cout<<v[i]<<" " ; }
//deletion in vector 
//{10 , 20 , 30 , 40 , 50}
v.erase(v.begin +1 ) ; //10 , 30 , 40 , 50 
v.erase(v.begin  , v.begin +2 ) // 40 , 50

v.insert(v.begin+1 , 300) ; // 40 , 300 , 50 
vector<int> copy(2 , 60) ;
v.insert(v.begin , copy.begin() , copy.end()) ;  //60 , 60 , 40 , 300 , 50
v.size() ; 
v2.swap(v) ;
